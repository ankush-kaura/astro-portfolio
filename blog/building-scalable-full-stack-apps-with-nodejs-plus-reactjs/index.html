<!DOCTYPE html><html lang="en"> <head><meta charset="utf-8"><meta name="robots" content="index, follow"><meta name="googlebot" content="index, follow"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="generator" content="Astro v4.16.19"><link rel="canonical" href="https://ankush-kaura.github.io/blog/building-scalable-full-stack-apps-with-nodejs-plus-reactjs/"><link rel="shortcut icon" type="image/svg+xml" href="https://ankush-kaura.github.io/astro-portfolio/favicon.svg"><title>Building Scalable Full-Stack Apps with Node.js + React.js</title><meta name="title" content="Building Scalable Full-Stack Apps with Node.js + React.js"><meta name="description" content="In today’s world of web apps and mobile apps, users expect things to be fast, smooth, and reliable no matter how many people use them. To build that kind of app you often need a full-stack setup: frontend (what the user sees) + backend (what the server does) + database/storage + scaling. In this blog we’ll talk about using Node.js (for the backend) and React.js (for the frontend) to build apps which are scalable (i.e., can handle growth) and user-friendly."><meta property="og:type" content="website"><meta property="og:url" content="https://ankush-kaura.github.io/blog/building-scalable-full-stack-apps-with-nodejs-plus-reactjs/"><meta property="og:title" content="Building Scalable Full-Stack Apps with Node.js + React.js"><meta property="og:description" content="In today’s world of web apps and mobile apps, users expect things to be fast, smooth, and reliable no matter how many people use them. To build that kind of app you often need a full-stack setup: frontend (what the user sees) + backend (what the server does) + database/storage + scaling. In this blog we’ll talk about using Node.js (for the backend) and React.js (for the frontend) to build apps which are scalable (i.e., can handle growth) and user-friendly."><meta property="og:image" content="https://ankush-kaura.github.io/blog/building-scalable-full-stack-apps-with-nodejs-plus-reactjs/View1.png"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://ankush-kaura.github.io/blog/building-scalable-full-stack-apps-with-nodejs-plus-reactjs/"><meta property="twitter:title" content="Building Scalable Full-Stack Apps with Node.js + React.js"><meta property="twitter:description" content="In today’s world of web apps and mobile apps, users expect things to be fast, smooth, and reliable no matter how many people use them. To build that kind of app you often need a full-stack setup: frontend (what the user sees) + backend (what the server does) + database/storage + scaling. In this blog we’ll talk about using Node.js (for the backend) and React.js (for the frontend) to build apps which are scalable (i.e., can handle growth) and user-friendly."><meta property="twitter:image" content="https://ankush-kaura.github.io/blog/building-scalable-full-stack-apps-with-nodejs-plus-reactjs/View1.png"><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><link rel="stylesheet" href="/assets/styles.css"><script type="module" src="/assets/hoisted.BScVxmeO.js"></script><style>[data-astro-transition-scope="astro-cnzgbifa-1"] { view-transition-name: astro-cnzgbifa-1; }@layer astro { ::view-transition-old(astro-cnzgbifa-1) { 
	animation-duration: 90ms, 220ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1), cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both, both;
	animation-name: astroFadeOut, astroSlideToLeft; }::view-transition-new(astro-cnzgbifa-1) { 
	animation-duration: 210ms, 220ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1), cubic-bezier(0.76, 0, 0.24, 1);
	animation-delay: 30ms;
	animation-fill-mode: both, both;
	animation-name: astroFadeIn, astroSlideFromRight; }[data-astro-transition=back]::view-transition-old(astro-cnzgbifa-1) { 
	animation-name: astroFadeOut, astroSlideToRight; }[data-astro-transition=back]::view-transition-new(astro-cnzgbifa-1) { 
	animation-name: astroFadeIn, astroSlideFromLeft; } }[data-astro-transition-fallback="old"] [data-astro-transition-scope="astro-cnzgbifa-1"],
			[data-astro-transition-fallback="old"][data-astro-transition-scope="astro-cnzgbifa-1"] { 
	animation-duration: 90ms, 220ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1), cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both, both;
	animation-name: astroFadeOut, astroSlideToLeft; }[data-astro-transition-fallback="new"] [data-astro-transition-scope="astro-cnzgbifa-1"],
			[data-astro-transition-fallback="new"][data-astro-transition-scope="astro-cnzgbifa-1"] { 
	animation-duration: 210ms, 220ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1), cubic-bezier(0.76, 0, 0.24, 1);
	animation-delay: 30ms;
	animation-fill-mode: both, both;
	animation-name: astroFadeIn, astroSlideFromRight; }[data-astro-transition=back][data-astro-transition-fallback="old"] [data-astro-transition-scope="astro-cnzgbifa-1"],
			[data-astro-transition=back][data-astro-transition-fallback="old"][data-astro-transition-scope="astro-cnzgbifa-1"] { 
	animation-name: astroFadeOut, astroSlideToRight; }[data-astro-transition=back][data-astro-transition-fallback="new"] [data-astro-transition-scope="astro-cnzgbifa-1"],
			[data-astro-transition=back][data-astro-transition-fallback="new"][data-astro-transition-scope="astro-cnzgbifa-1"] { 
	animation-name: astroFadeIn, astroSlideFromLeft; }</style></head> <body class="min-h-screen bg-background font-sans antialiased"> <div class="flex flex-col items-center justify-center"> <script>
  document.addEventListener('astro:after-swap', function () {
    if (localStorage.getItem('theme') === 'dark')
      document.documentElement.classList.toggle('dark', true)
  })

  const getThemePreference = () => {
    return localStorage.getItem('theme')
  }

  const isDark = getThemePreference() === 'dark'
  document.documentElement.classList[isDark ? 'add' : 'remove']('dark')
</script> <header class="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60"> <div class="container flex h-16 items-center justify-between px-4 sm:px-6"> <div class="flex items-center"> <a href="/" class="flex items-center space-x-2"> <span class="inline-block font-bold text-sm sm:text-base">Ankush Kaura</span> </a> </div> <div class="flex items-center space-x-2 sm:space-x-4"> <nav class="flex items-center space-x-1 sm:space-x-2"> <a href="https://github.com/ankush-kaura" target="_blank" rel="noreferrer" class="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 hover:bg-accent hover:text-accent-foreground h-9 rounded-md px-3"> <span class="hidden sm:inline">GitHub</span> <span class="sm:hidden">GH</span> </a> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();;(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="10JN9h" prefix="r0" component-url="/assets/ThemeToggle.DqC9x9ri.js" component-export="ModeToggle" renderer-url="/assets/client.C3oXHFXl.js" props="{&quot;data-astro-transition-persist&quot;:[0,&quot;astro-ttma6qni-2&quot;]}" ssr="" client="load" opts="{&quot;name&quot;:&quot;ModeToggle&quot;,&quot;value&quot;:true}" data-astro-transition-persist="astro-ttma6qni-2" await-children=""><button class="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 border border-input bg-background hover:bg-accent hover:text-accent-foreground h-10 w-10" type="button" id="radix-:r0R0:" aria-haspopup="menu" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-sun h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-moon absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg><span class="sr-only">Toggle theme</span></button><!--astro:end--></astro-island> </nav> </div> </div> </header>  <main class="flex min-h-[80vh] flex-auto flex-col" data-astro-transition-scope="astro-cnzgbifa-1"> <div class="pb-4 pt-24 sm:pt-32 md:pt-36"> <div class="w-full h-full mx-auto px-5 max-w-screen-md">   <div class="mb-4 sm:mb-6"> <a href="/blogs" class="text-primary hover:underline text-sm sm:text-base">&larr; Back to Blogs</a> </div> <h1 class="scroll-m-20 text-2xl sm:text-3xl lg:text-4xl xl:text-5xl font-extrabold tracking-tight"> Building Scalable Full-Stack Apps with Node.js + React.js </h1> <p class="text-base sm:text-lg text-muted-foreground mt-2"> In today’s world of web apps and mobile apps, users expect things to be fast, smooth, and reliable no matter how many people use them. To build that kind of app you often need a full-stack setup: frontend (what the user sees) + backend (what the server does) + database/storage + scaling. In this blog we’ll talk about using Node.js (for the backend) and React.js (for the frontend) to build apps which are scalable (i.e., can handle growth) and user-friendly. </p> <p class="text-sm text-gray-500 mt-2">
Published on 10/24/2025 </p>   </div> </div> <div class="flex-1 py-4 sm:py-6 lg:py-8"> <div class="w-full h-full mx-auto px-5 max-w-screen-md">   <article class="prose dark:prose-invert max-w-none"> <img src="https://images.ctfassets.net/2y2ueqm0l7y8/4xw25mCDy4iX9DVj7TEcpq/0d06c586b104253add8dd11e05c8090d/image.png" alt="An Insigntful Guide on Full Stack Developement" class="w-full h-48 sm:h-56 lg:h-64 xl:h-72 object-cover rounded-lg mb-6 sm:mb-8"> <div><h2>Introduction</h2><p>In today’s world of web apps and mobile apps, users expect things to be fast, smooth, and reliable no matter how many people use them. To build that kind of app you often need a <b>full-stack setup</b>: frontend (what the user sees) + backend (what the server does) + database/storage + scaling. In this blog we’ll talk about using Node.js (for the backend) and React.js (for the frontend) to build apps which are <b>scalable</b> (i.e., can handle growth) and user-friendly.</p><h2>What exactly are Node.js and React.js?</h2><p>Let’s break them down in simple terms:</p><ul><li><p><b>Node.js</b>: Think of it as a toolkit that lets you run JavaScript on the server (instead of just in the browser). You can build APIs, handle requests, talk to databases, manage files, etc.</p></li><li><p><b>React.js</b>: A library (toolkit) for building user interfaces in the browser — the buttons, lists, pages, and the parts of your app the user interacts with.</p></li></ul><p>Why use them together? Because both use JavaScript, you can share ideas and sometimes code between frontend and backend, it simplifies the mental load. You don’t have to learn a completely different language for server vs browser.</p><h2>Why build scalable apps?</h2><p>Scalable means: your app works well even when lots of people use it, data grows, new features get added. Here are key points:</p><ul><li><p><b>Handling growth</b>: More users, more requests, more data. The system should cope without crashing or becoming extremely slow.</p></li><li><p><b>Maintainability</b>: As your app grows, you want to avoid spaghetti code. Using clean structure + good tools helps.</p></li><li><p><b>Cost &amp; performance</b>: Inefficient apps cost more (servers, bandwidth). If you build smarter, you save money and deliver better experience.</p></li><li><p><b>Future-proofing</b>: You might start small, but you want to be ready for bigger usage, new features, maybe mobile etc.</p></li></ul><hr/><h2>How does Node.js + React.js help with scalability?</h2><p>Here are ways this tech stack supports building scalable full-stack apps:</p><ol><li><p><b>Same language across stack</b>
 Because both frontend and backend use JavaScript (Node on the server, React in browser), you don’t need developers switching mental context or learning many languages. This speeds up development and reduces mis-communication.</p></li><li><p><b>Componentised frontend</b>
 React lets you build UI as pieces (components) which you can reuse. That means when your app grows, you won’t recreate everything; you reuse. It also helps maintainability.</p></li><li><p><b>Efficient backend with Node.js</b>
 Node is built with a non-blocking model: it can handle many simultaneous requests without waiting for each one to finish before starting the next. That’s good for handling lots of users.
 Also many packages and tools (npm modules) help you scale (e.g., clustering, micro-services, caching).</p></li><li><p><b>Clear separation of concerns</b>
 React handles UI, Node handles server logic. You can evolve each part independently. For example you can scale your server infrastructure separately from your frontend rendering.</p></li><li><p><b>Modern tools &amp; ecosystem</b>
 The Node + React ecosystem has lots of libraries/modules, strong community, deployment options (cloud, containers, serverless). That means you can pick tools that scale and integrate well.</p></li></ol><h2>A simple blueprint: how to structure your full-stack app</h2><p>Here’s a high-level blueprint for how you might organise a scalable Node + React full-stack app:</p><h3>Frontend (React)</h3><ul><li><p>React components for UI (buttons, forms, lists)</p></li><li><p>State management (e.g., using React’s built-in hooks or a library)</p></li><li><p>Routing (single-page app) so user navigates without full page reloads</p></li><li><p>API calls to backend (fetch/axios) to get/post data</p></li></ul><h3>Backend (Node)</h3><ul><li><p>Express.js (or another framework) for handling HTTP requests</p></li><li><p>Define RESTful APIs (or GraphQL) which frontend uses</p></li><li><p>Handle authentication/authorization</p></li><li><p>Talk to database (SQL or NoSQL)</p></li><li><p>Business logic (what your app “does”)</p></li><li><p>Logging, error handling, monitoring</p></li></ul><h3>Database &amp; Storage</h3><ul><li><p>Choose based on your use case: relational (SQL) or document (NoSQL)</p></li><li><p>Use connection pooling, indexing, queries optimized for growth</p></li><li><p>Possibly caching layer (Redis/Memcached) for speed</p></li></ul><h3>Deployment &amp; Scaling</h3><ul><li><p>Deploy backend and frontend (can be separate)</p></li><li><p>Use environment variables for config (so you can change without code)</p></li><li><p>Monitoring (logs, metrics) to see when things get slow</p></li><li><p>Horizontal scaling: adding more instances rather than one big machine</p></li><li><p>Use of containers (Docker), orchestration (Kubernetes) perhaps</p></li><li><p>Use CDN for static assets (images, scripts) so front-end is fast</p></li></ul><hr/><h2>Practical tips and best practices</h2><p>Here are some suggestions to help you build right from the start (so you don’t regret later):</p><ul><li><p>Keep your code modular (both frontend and backend). Small components/functions are easier to test and scale.</p></li><li><p>Version control (Git) and branching strategy: you’ll thank yourself later.</p></li><li><p>Write automated tests: unit tests and integration tests, so changes don’t break things.</p></li><li><p>Use environment specific configs (dev, test, prod) so you can change behaviour based on where app runs.</p></li><li><p>Monitor performance early: track response times, error rates, user behaviour.</p></li><li><p>Optimize your database queries: when you have lots of data, slow queries will kill you.</p></li><li><p>Use caching where it makes sense.</p></li><li><p>Use asynchronous operations in backend (Node supports this) so you’re not blocking threads.</p></li><li><p>Keep security in mind: validate inputs, protect endpoints, secure secrets.</p></li><li><p>For frontend, lazy-load heavy parts (so initial load is fast), minimise bundle size.</p></li><li><p>Use static hosting or CDNs for the React build where possible (since static assets scale well).</p></li></ul><hr/><h2>Example scenario: Imagine a task-manager app</h2><p>Let’s walk through a simple example to bring it all together. Suppose you’re building a “task-manager” web app for teams:</p><ol><li><p>Frontend React: shows list of tasks, create new task form, edit task modal, user login.</p></li><li><p>Backend Node: endpoints like <code>/api/tasks</code> (GET, POST, PUT, DELETE), <code>/api/users/login</code>, <code>/api/users/register</code>.</p></li><li><p>Database: tasks collection/table with fields like id, title, description, assignedTo, status, createdAt.</p></li><li><p>Deployment: react build hosted on a static host + CDN for js/css/images; node backend runs in a cloud server/instance. Load-balancer sits in front if many users.</p></li><li><p>Scaling: if 100 users it’s fine; if 10,000 users you add more backend instances, database maybe shard or optimise queries, caching of frequent queries (e.g., tasks list) so you&#39;re not hitting DB for every request.</p></li><li><p>Maintenance: React components are reused (TaskItem, TaskList, TaskForm), backend modules separated (routes, controllers, services). Tests ensure tasks logic still works when you change something.</p></li></ol><hr/><h2>Common challenges &amp; how to overcome them</h2><p>Even with Node + React, building a truly scalable app isn’t trivial. Here are some challenges and responses:</p><ul><li><p><b>Too many simultaneous requests</b>: If backend isn’t asynchronous or blocking, you’ll be bottlenecked. Use Node’s non-blocking model, thread pools if needed.</p></li><li><p><b>Slow database queries</b>: If you don’t index or use proper queries, slowdown. Monitor DB, optimise, use caching.</p></li><li><p><b>Large frontend bundle</b>: If React build is huge, load time suffers especially on mobile. Solve by code-splitting, lazy loading, compressing assets.</p></li><li><p><b>Poor modularity</b>: One huge file for everything = hard to maintain. Keep modules/components small and well-defined.</p></li><li><p><b>Deployment complexity</b>: Scaling might mean deploying multiple services, maybe micro-services. Start simple but design so you can evolve.</p></li><li><p><b>Security &amp; auth</b>: When you grow, user accounts, permissions, data protection become critical. Don’t ignore these for early version.</p></li><li><p><b>State management complexity</b>: As frontend gets bigger, managing state (which component has what data) becomes tricky. Use appropriate state libs or React context wisely.</p></li></ul><hr/><h2>Why this stack is a good fit right now</h2><ul><li><p>JavaScript is everywhere: you don’t need separate languages for front &amp; back.</p></li><li><p>React is extremely popular and well supported: lots of community, libraries, learning materials.</p></li><li><p>Node.js is also very mature: many companies use it for backend services.</p></li><li><p>There are tons of starter kits (boilerplates), templates, open-source code to speed you up.</p></li><li><p>Because of popularity, hiring developers (or yourself learning) is easier.</p></li><li><p>It aligns with modern deployment practices: micro-services, serverless, containerised deployments.</p></li></ul><hr/><h2>Final thoughts</h2><p>If you’re planning to build a full-stack web app that you expect to grow (more users, more features, more data) then choosing the right stack and architecture from early on matters a lot. Using Node.js + React.js gives you a strong foundation: same language, strong communities, modular components, scalable architecture.</p><p>Start with a clean structure, adopt best practices, keep performance and maintenance in mind — and you’ll save yourself a lot of pain later when your app grows.</p><p>The key: build <b>smart</b>, build <b>scalable</b>.</p><p></p></div> </article>   </div> </div> </main>  <footer class="border-t py-6 md:px-8 md:py-0"> <div class="container flex flex-col items-center justify-between gap-4 md:h-24 md:flex-row"> <p class="text-center text-sm leading-loose text-muted-foreground md:text-left">
Built by  <a href="https://github.com/ankush-kaura" target="_blank" rel="noreferrer" class="font-medium underline underline-offset-4">
Ankush Kaura
</a>
. with <span class="text-red-500">❤️</span> using Astro and Tailwind CSS.
</p> </div> </footer> </div> </body></html>